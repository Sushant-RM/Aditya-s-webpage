<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computation Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            padding: 0;
            background-color: #f8f9fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
        }
        ul {
            margin-left: 20px;
            padding-left: 0;
        }
        li {
            list-style-type: disc;
            margin-bottom: 10px;
        }
        section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <h1>Algorithms concept</h1>
    <section>
        <h2>1. Problems in Nature (Iteration, Recursion, Backtracking)</h2>
        <h3>Iteration</h3>
        <p>Ecosystem Cycles, Population Dynamics, Nature patterns</p>
        <h3>Recursion</h3>
        <p>Mountains, river networks, and exhibit self-similarity, Fibonacci Sequence, Cell Division</p>
        <h3>Backtracking</h3>
        <p>Backtracking is used to solve puzzles like Sudoku, crosswords, and word searches, Maze Solving, etc.</p>
    </section>
    <section>
        <h2>2. Space and Time Complexity</h2>
        <h3>Space Complexity</h3>
        <p>Measures the memory required by an algorithm.</p>
        <p><b>Importance:</b> Optimize computational resources (memory and time).</p>
        <h3>Time Complexity</h3>
        <p>Measures how execution time grows with input size.</p>
        <p><b>Importance:</b> Ensure scalability for large inputs in real-world applications.</p>
        <h3>Orders of Growth:</h3>
        <ul>
            <li>Constant O(1): Accessing array elements.</li>
            <li>Logarithmic O(log n): Binary search.</li>
            <li>Linear O(n): Single-pass algorithms.</li>
            <li>Quadratic O(n²): Nested loops like Bubble Sort.</li>
            <li>Exponential O(2ⁿ): Recursive algorithms like the Tower of Hanoi.</li>
        </ul>
        <h3>What criteria do you use to evaluate the effectiveness of a solution?</h3>
        <p>  Evaluate based on correctness, time complexity, space efficiency.</p>
    </section>
    <section>
        <h2>3. Takeaways from Different Design Principles from chapter 2</h2>
        <p>The concepts and techniques discussed here form the foundation of computational thinking and algorithm design. They demonstrate how complex problems can be tackled through systematic approaches, efficiency improvements.</p>
        <h3>Key Design Principles:</h3>
        <ul>
            <li><b>Decomposition:</b> Decomposition is the process of breaking down a large, complex problem into smaller, more manageable sub-problems. </li>
            <h2>Reflect on how breaking down a problem into smaller components can help you approach it more effectively.</h2>
            <p>Breaking down a problem into smaller components simplifies complexity making the overall problem easier to solve efficiently.</p>
            <li><b>Pattern Recognition:</b> Pattern recognition involves identifying recurring patterns or similarities within a problem, enabling generalizations and predictions.</li>
            <li><b>Abstraction:</b> Abstraction simplifies complex systems by focusing on essential features and ignoring irrelevant details.  </li>
            <li><b>Brave and Cautious Travel:</b> Brave traversal involves moving until a dead end and backtracking step by step as in Depth First Search (DFS). Cautious traversal progresses level by level, as in Breadth First Search (BFS).  </li>
            <li><b>Pruning:</b>Pruning eliminates unnecessary parts of a problem to improve efficiency, it prevents exploration of irrelevant paths, such as in the N-Queen’s problem, saving time and space.</li>
            <li><b>Lazy Propagation:</b> Lazy propagation optimizes performance in data structures like segment trees by deferring updates until necessary. This technique improves efficiency for large datasets, enabling logarithmic time complexity for updates.</li>
            <li><b>Sliding Window:</b> The sliding window technique analysis overlapping sub-arrays or sub-sequences by maintaining relevant information from previous windows. It is effective for problems like finding maximum sums or substring searches </li>
            <li><b>Level Order Traversal:</b> Level order traversal systematically explores tree nodes level by level. It processes nodes breadth-wise and is directly related to BFS traversal in graphs.</li>
            <li><b>Hierarchical Data:</b> Hierarchical data structures, like family trees, organize information in parent-child relationships.  </li>
            <li><b>Edge Relaxation:</b> Edge relaxation is a key concept in shortest-path algorithms. It updates the shortest known distance to a vertex by checking paths through neighbouring vertices </li>
            <li><b>Balancing and Rotations:</b> Balancing and rotations maintain efficiency in tree-based data structures by preventing skewed trees. These techniques are essential for optimal performance in AVL and Red-Black trees.</li>
            <li><b>Kleene Closure:</b> Kleene closure relates to transitivity in automata and graph theory. It determines relationships between graph elements and computes transitive closure, aiding in shortest path algorithms and social network analysis.</li>
            <li><b>Pre-Computing:</b> Pre-computing enhances performance by calculating and storing frequently used results in advance. It reduces runtime calculations, particularly in lookup tables and dynamic programming.</li>
            <li><b>Parental Dominance:</b> Parental dominance ensures hierarchical efficiency in data structures like heaps, where the root contains the largest or smallest element. It is crucial for operations like priority queuing and sorting.</li>
            <li><b>Prefix and Suffix:</b> Prefixes and suffixes aid in pattern matching and string operations. They are vital for tasks like searching, bioinformatics, and natural language processing.</li>
            <li><b>Partitioning:</b> Partitioning divides problems into smaller sub-problems for recursive solving, enhancing efficiency. It is widely applied in sorting, searching, and graph algorithms.</li>
            <li><b>Bit Manipulations:</b> Bit manipulations optimize memory and computation through operations like AND, OR, XOR, and shifting. Techniques like Fenwick trees demonstrate their utility in creating efficient data structures.</li>
            <li><b>Memoization:</b> Memoization optimizes recursive algorithms by storing previously computed results. It is a core concept in dynamic programming, preventing redundant calculations and reducing time complexity.</li>
            <li><b>Invariants:</b>Invariants are conditions that remain constant during program execution. They are essential for debugging, testing, and ensuring algorithm correctness, such as maintaining sorted order in sorting algorithms.</li>
            <li><b>Shortest Path Trees:</b> Shortest path trees illustrate the shortest routes from a starting node to all others. These are foundational in navigation, routing, and network optimization.</li>
             <h2>How do you determine the most efficient approach when solving a complex problem?</h2>
            <p>Analyse the problem, evaluate constraints, choose suitable data structures and algorithms, and optimize for time and space complexity based on the requirements.</p>
        </ul>
    </section>
    <section>
        <h2>4.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios  </h2>
        <p><b>Trees:</b> Trees are used for hierarchial data organization. It also gives efficient traversals for structured data. This is base structure for the upcoming optimisations in trees. Here the traversals can be costly in unbalanced conditions hence we optimise to Binary search trees.</p>
        <ul>
            <li><b>Binary Search Tree:</b> It facilitates the searching, insertion and deletion operations. Here it follows the property left child<= parent<= right.This can become unbalanced, leading to worst case O(n). Hence we move to AVL trees.  </li>
            <li><b>AVL Trees:</b> It is  a Binary search tree which self-balances itself based on the balance factor. Its mainly done using single or double rotations generally after the insertions or deletions. But this frequent rotations increases the stack overhead, hence to optimise we move to 2-3 trees.</li>
            <li><b>2-3 Trees:</b>A type of BST having 2 children or no children. It ensures all leaves are at the same level. It supports efficient searching, insertion and deletion.</li>
            <li><b>Red-Black Trees:</b> A type of BST which follows colour based rules. It ensures no two red nodes are adjacent and maintains approximately balanced height and maintains O(log n) .</li>
            <li><b>Heap:</b> Uses priority queue implementation and is used in graph algorithms like Dijkstra’s and Kruskal’s but it limits itself for priority based operations and rebalancing it during insertion and deletion is time consuming.</li>
            <li><b>Trie:</b> It is a prefix tree used for storing strings efficiently. Each path from the root represents a unique string. This has its application in dictionary, passwords, autocomplete etc</li>
        </ul>
    </section>
    <section>
        <h2>5. The need of array query algorithms and their implications. Their applications and principles</h2>
        <p>Array query algorithms are needed for efficiently solving problems that involves queries and updating the data stored in arrays.
It is efficient in data updation, handling of dynamic data.
</p>
        <ul>
            <h2>Applications:</h2>
            <li><b>1.Range query:</b>Sum, max, min in a sub array can be calculated efficiently</li> 
            <li><b>2.Dynamic updates:</b>Incrementing values in a range or updating specific elements.</li>
            <li>3.Also it matches the sequence using patterns and it is also used in Graph algorithms for example to find shortest path in Dijkstra</li>
            <li>It follows the design principles of </li>
            <li>•Pre-computation: computes and store results of queried data in advance</li>
            <li>•Divide and conquer: Break the array into smaller subarrays to solve queries</li>
            <li>•Sliding Window: maintains window of useful data while traversing the array</li>
            <li>•Dynamic programming: uses previous solutions to compute subproblems.</li>
            <li>•Lazy propagation: Delays updates until necessary</li>
            <li>It gives improved performance, optimised resource utilization, wide applicability and scalability.</li>
        </ul>
    </section>
    <section>
        <h2>6.Differentiate between tree and graphs and their traversals. The applications of each</h2>
        <ul>
            <h2>Tree</h2>
            <li>Tree is a hierarchical data structure with nodes connected by edgeand no cycles. It always has a single root node and each child has exactly one parent.</li>
            <li>In tree traversal there is only one unique path between any two nodes.</li>
            <li>Traversal is done using Pre, In, Post-order traversals.</li>
            <h2>Graphs</h2>
            <li>Graph is a collection of vertices connected by edges which may form cycles. It does not have a root node any node can be a starting point</li>
            <li>In graph traversal multiple paths may exist between nodes.</li>
            <li>Traversals are done using DFS and BFS</li>
            <h2>Applications:</h2>
            <li>Trees are used in BST, heaps, tries etc.</li>
            <li>Graphs are used in social networks, Web graphs	</li>
        </ul>
        
    </section>
    <section>
        <h2>7. Deliberate on sorting and searching algorithms, the technique behind each and they connect to real worlds</h2>
        <h2>Sorting Techniques:</h2>
        <ul>
            <li><b>1.Bubble Sort:</b>Simple but inefficient (O(n²)), used for small datasets.</li>
            <li><b>2.Selection Sort:</b>Places elements in sorted order by repeatedly selecting the smallest/largest (O(n²)).</li>
            <li><b>3.Insertion Sort:</b>Efficient for nearly sorted data (O(n²)).</li>
            <li><b>4.Merge Sort:</b>Divides data recursively, then merges (O(n log n)).</li>
            <li><b>5.Quick Sort:</b>Uses partitioning for fast sorting (O(n log n), worst-case O(n²)).</li>
            <li><b>6.Heap Sort:</b>Employs a heap for sorting (O(n log n), in-place).</li>
        </ul>
         <section>
        <h2>Searching Algorithms</h2>
        <ul>
            <li><strong>Linear Search:</strong> Checks each element sequentially.</li>
            <li><strong>Binary Search:</strong> Efficiently finds an element in a sorted array by halving the search range.</li>
        </ul>
    </section>

    <section>
        <h2>Graph Algorithms</h2>
        <p>Graph algorithms deal with problems involving graphs like finding shortest paths, spanning trees, and connectivity.</p>
        <ul>
            <li><strong>Dijkstra's Algorithm:</strong> Finds the shortest path from a source node to all other nodes.</li>
            <li><strong>Floyd-Warshall Algorithm:</strong> Calculates shortest paths between all pairs of nodes.</li>
            <li><strong>Prim's Algorithm:</strong> Finds the Minimum Spanning Tree (MST) of a graph.</li>
            <li><strong>Union-Find:</strong> Detects connected components.</li>
            <li><strong>Shortest Path:</strong> Finds the minimum path between nodes (e.g., Dijkstra’s, Bellman-Ford).</li>
            <li><strong>Spanning Trees:</strong> Optimizes network design (e.g., Prim’s, Kruskal’s).</li>
        </ul>
    </section>

    <section>
        <h2>Real-World Applications</h2>
        <ul>
            <li><strong>Sorting/Searching:</strong> Used in databases, scheduling, and e-commerce.</li>
            <li><strong>Graph Algorithms:</strong> Essential for navigation, network optimization, and logistics.</li>
        </ul>
    </section>
</body>
</html>
