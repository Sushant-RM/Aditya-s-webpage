<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computation Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            padding: 0;
            background-color: #f8f9fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
        }
        ul {
            margin-left: 20px;
            padding-left: 0;
        }
        li {
            list-style-type: disc;
            margin-bottom: 10px;
        }
        section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <h1>Computation Concepts and Techniques</h1>
    <section>
        <h2>1. Problems in Nature (Iteration, Recursion, Backtracking)</h2>
        <h3>Iteration</h3>
        <p>Ecosystem Cycles, Population Dynamics, Nature patterns</p>
        <h3>Recursion</h3>
        <p>Mountains, river networks, and exhibit self-similarity, Fibonacci Sequence, Cell Division</p>
        <h3>Backtracking</h3>
        <p>Backtracking is used to solve puzzles like Sudoku, crosswords, and word searches, Maze Solving, etc.</p>
    </section>
    <section>
        <h2>2. Space and Time Complexity</h2>
        <h3>Space Complexity</h3>
        <p>Measures the memory required by an algorithm.</p>
        <p><b>Importance:</b> Optimize computational resources (memory and time).</p>
        <h3>Time Complexity</h3>
        <p>Measures how execution time grows with input size.</p>
        <p><b>Importance:</b> Ensure scalability for large inputs in real-world applications.</p>
        <h3>Orders of Growth:</h3>
        <ul>
            <li>Constant O(1): Accessing array elements.</li>
            <li>Logarithmic O(log n): Binary search.</li>
            <li>Linear O(n): Single-pass algorithms.</li>
            <li>Quadratic O(n²): Nested loops like Bubble Sort.</li>
            <li>Exponential O(2ⁿ): Recursive algorithms like the Tower of Hanoi.</li>
        </ul>
        <p><b>Criteria to Evaluate Solution Effectiveness:</b> Evaluate based on correctness, time complexity, space efficiency.</p>
    </section>
    <section>
        <h2>3. Takeaways from Different Design Principles</h2>
        <p>The concepts and techniques discussed here form the foundation of computational thinking and algorithm design. They demonstrate how complex problems can be tackled through systematic approaches and efficiency improvements.</p>
        <h3>Key Design Principles:</h3>
        <ul>
            <li><b>Decomposition:</b> Breaking down a large, complex problem into smaller, more manageable sub-problems.</li>
            <li><b>Pattern Recognition:</b> Identifying recurring patterns or similarities within a problem.</li>
            <li><b>Abstraction:</b> Simplifying complex systems by focusing on essential features.</li>
            <li><b>Brave and Cautious Travel:</b> DFS and BFS traversal techniques.</li>
            <li><b>Pruning:</b> Eliminates unnecessary parts of a problem (e.g., N-Queen's problem).</li>
            <li><b>Lazy Propagation:</b> Optimizes performance in data structures by deferring updates.</li>
            <li><b>Sliding Window:</b> Efficient analysis of overlapping subarrays or subsequences.</li>
            <li><b>Level Order Traversal:</b> Systematically explores tree nodes level by level.</li>
            <li><b>Hierarchical Data:</b> Organizes information in parent-child relationships.</li>
            <li><b>Edge Relaxation:</b> Key in shortest-path algorithms.</li>
            <li><b>Balancing and Rotations:</b> Maintains efficiency in tree-based data structures.</li>
            <li><b>Kleene Closure:</b> Relates to transitivity in automata and graph theory.</li>
            <li><b>Pre-Computing:</b> Enhances performance by pre-calculating results.</li>
            <li><b>Parental Dominance:</b> Ensures hierarchical efficiency in data structures like heaps.</li>
            <li><b>Prefix and Suffix:</b> Used in pattern matching and string operations.</li>
            <li><b>Partitioning:</b> Divides problems into smaller sub-problems.</li>
            <li><b>Bit Manipulations:</b> Optimizes memory and computation through binary operations.</li>
            <li><b>Memoization:</b> Optimizes recursive algorithms by storing results.</li>
            <li><b>Invariants:</b> Conditions that remain constant during execution.</li>
            <li><b>Shortest Path Trees:</b> Foundational in navigation, routing, and network optimization.</li>
        </ul>
    </section>
    <section>
        <h2>4. Hierarchical Data and Tree Structures</h2>
        <p><b>Trees:</b> Hierarchical data organization, base for upcoming optimizations.</p>
        <ul>
            <li><b>Binary Search Tree:</b> Efficient searching, insertion, deletion.</li>
            <li><b>AVL Trees:</b> Self-balancing BST with single/double rotations.</li>
            <li><b>2-3 Trees:</b> Ensures balanced height; efficient searching.</li>
            <li><b>Red-Black Trees:</b> Color-based balanced BST.</li>
            <li><b>Heap:</b> Priority queue implementation, used in graph algorithms.</li>
            <li><b>Trie:</b> Efficient prefix-based data storage.</li>
        </ul>
    </section>
    <section>
        <h2>5. Array Query Algorithms and Implications</h2>
        <p>Efficient for solving problems involving queries and data updates.</p>
        <ul>
            <li>Applications: Range queries, dynamic updates, pattern matching.</li>
            <li>Principles: Pre-computation, divide and conquer, sliding window, lazy propagation.</li>
        </ul>
    </section>
    <section>
        <h2>6. Tree vs. Graph and Traversals</h2>
        <ul>
            <li><b>Tree:</b> Hierarchical, no cycles, unique path between nodes.</li>
            <li><b>Graph:</b> General structure, cycles possible, multiple paths between nodes.</li>
        </ul>
        <p>Applications: Trees in BST, heaps; Graphs in networks, social graphs.</p>
    </section>
    <section>
        <h2>7. Sorting and Searching Algorithms</h2>
        <h3>Sorting Techniques:</h3>
        <ul>
            <li>Bubble Sort, Selection Sort, Insertion Sort: Simple but inefficient for large data.</li>
            <li>Merge Sort, Quick Sort, Heap Sort: Efficient for large datasets.</li>
        </ul>
        <h3>Searching Techniques:</h3>
        <ul>
            <li>Linear Search: Sequential checks.</li>
            <li>Binary Search: Efficient in sorted arrays.</li>
        </ul>
        <h3>Graph Algorithms:</h3>
        <ul>
            <li>Dijkstra's: Shortest path from source to all nodes.</li>
            <li>Prim's: Minimum Spanning Tree.</li>
        </ul>
        <p>Applications: Sorting/Searching in e-commerce, Graphs in logistics and navigation.</p>
    </section>
</body>
</html>
